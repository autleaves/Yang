<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
        rel="stylesheet">

    <link href="../../css/base.css" rel="stylesheet">
    <link href="../../css/lib.css" rel="stylesheet">
    <link href="../../css/common.css" rel="stylesheet">
    <link href="../../css/coms/com-nav.css" rel="stylesheet">
    <link href="../../css/coms/com-search.css" rel="stylesheet">
    <link href="../../css/coms/com-explore.css" rel="stylesheet">
    <link href="../../css/header.css" rel="stylesheet">
    <link href="../../css/footer.css" rel="stylesheet">

    <script src="../../js/search.js" type="text/javascript" defer></script>
    <script src="../../js/menu.js" type="text/javascript" defer></script>
    <title>Elementary Symbol Tables</title>


</head>

<body class="searching">
    <header class="header null">
        <div class="logo null">
            <a href="../../index.html"><img src="../../images/base/logo2.png"></a>
        </div>
        <nav class="-lib--menu null" id="main-menu">
            <div class="-lib--menu-backdrop"></div>
            <div class="-lib--menu-body">
                <button class="-lib--menu-toggle -utils--position-btn" id="toggle-menu">
                    <i class="-utils--sr-only">toggle menu</i>
                </button>
                <div class="-lib--menu-dropdown null">
                    <ul class="nav-menu">
                        <li class="nav_fundamentals"><a href="../../pages/fu/fundamentals.html">Fundamentals</a></li>
                        <li class="nav_sorting"><a href="../../pages/so/sorting.html">Sorting</a></li>
                        <li class="nav_searching"><a href="../../pages/se/searching.html">Searching</a></li>
                        <li class="nav_graphs"><a href="../../pages/gr/graphs.html">Graphs</a></li>
                        <li class="nav_strings"><a href="../../pages/st/strings.html">Strings</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <div class="contact-us--icons null">
            <a href="https://github.com/"><img src="../../images/base/github-mark.png" alt="GitHub"></a>
            <a href="mailto:@gmail.com"><img src="../../images/base/email-mark.png" alt="Email"></a>
        </div>
    </header>
    <main class="">
        <div class="contents">
            <aside class="">
                <div class="topicpath null">
                    <ol>
                        <li class="topicpath-icon"><span>&nbsp;</span></li>
                        <li><a class="underline" href="../../index.html">Home</a>&nbsp;&gt;</li>
                        <li><a class="underline" href="./searching.html">Searching</a>&nbsp;&gt;</li>
                        <!-- <li>Bags, Queues, and Stacks</li> -->
                    </ol>
                </div>
                <!-- <div>>>>>>>>>>>>>>>>>>>>>>>>>>>>></div> -->
                <ul class="sub-nav ">
                    <!-- <li><a href="">Fundamentals</a>
                    <ol> -->
                    <li class="sub-nav-current"><a href="./Elementary Symbol Tables.html">
                            <div class="icon-container ">&nbsp;
                            </div>
                            <div class="">
                                <span>Elementary Symbol Tables</span>
                            </div>
                        </a></li>
                    <li><a href="./Binary Search Trees.html">
                            <div class="icon-container ">&nbsp;
                            </div>
                            <div class="">
                                <span>Binary Search Trees</span>
                            </div>
                        </a></li>
                    <li><a href="./Balanced Search Trees.html">
                            <div class="icon-container ">&nbsp;
                            </div>
                            <div class="">
                                <span>Balanced Search Trees</span>
                            </div>
                        </a></li>
                    <li><a href="./Hash Tables.html">
                            <div class="icon-container ">&nbsp;
                            </div>
                            <div class="">
                                <span>Hash Tables</span>
                            </div>
                        </a></li>
                    <!-- </ol>
                    </li> -->
                </ul>
            </aside>
            <article>
                <section class="section">
                    <div class="section-container ">
                        <div class="section-title chapter-title">
                            <h1>Bags, Queues, and Stacks</h1>
                        </div>
                        <div class="section-content chapter-content">
                            
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class="">&sect;&nbsp;</h2>
                        </div>
                        <div class="section-content">
                            
                        </div>
                    </div>
                </section>
                <section class="section">
                    <div class="section-container">
                        <div class="section-title">
                            <h2 class=""><img src="../../images/base/paper-clip.png">&nbsp;</h2>
                        </div>
                        <div class="section-content">
                            
                        </div>
                    </div>
                </section>
            </article>
        </div>
    </main>
    <footer class="footer">
        <div class="footer__inner">
            <small>Copyright &copy; 2024 Yang, Inc.</small>
        </div>
    </footer>
</body>

</html>


<div id = "content">
    <H1>3.1 &nbsp; Elementary Symbol Tables</H1>
    
    <p><br>
    
    <h2>Symbol table.</h2>
    The primary purpose of a <em>symbol table</em> is to associate
    a <em>value</em> with a <em>key</em>.
    The client can <em>insert</em> keyâ€“value pairs into the symbol table
    with the expectation of later being able to 
    <em>search</em> for the value associated with a given key.
    
    <p>
    <center>
    <IMG SRC="images/symbol-table-applications.png" alt = "Typical symbol-table applications">
    </center>
    
    
    <p><h2>API.</h2>
    Here is the API.
    
    <p>
    <center>
    <IMG SRC="images/symbol-table-api.png" alt = "Symbol-table API">
    </center>
    
    We consider several design choices for our implementations to 
    make our code consistent, compact, and useful.
    
    <ul>
    <p><li><em>Generics.</em>
    We consider the methods without specifying the types of keys
    and values being processed, using generics.
    
    <p><li><em>Duplicate keys.</em>
    Only one value is associated with each key (no duplicate keys in a table).
    When a client puts a key-value pair into a table already
    containing that key (and an associated value), the new value replaces the 
    old one.
    These conventions define the <em>associative array abstraction</em>,
    where you can think of a symbol table as being just like
    an array, where keys are indices and values are array entries.
    
    <p><li><em>Null values.</em>
    No key can be associated with the value <tt>null</tt>.
    This convention is directly tied to our specification in the
    API that <tt>get()</tt> should return <tt>null</tt> for keys not in
    the table.
    This convention has two (intended) consequences:
    First, we can test whether or not the symbol table defines
    a value associated with a given key by testing whether 
    <tt>get()</tt> returns <tt>null</tt>.
    Second, we can use the operation of calling <tt>put()</tt>
    with <tt>null</tt> as its second (value) argument to
    implement deletion.
    
    <p><li><em>Deletion.</em>
    Deletion in symbol tables generally involves one of two strategies:
    <em>lazy</em> deletion, where we associate keys in the table with <tt>null</tt>,
    then perhaps remove all such keys at some later time,
    and <em>eager</em> deletion, where we remove the key from the table 
    immediately.
    As just discussed, the code <tt>put(key, null)</tt> is an easy (lazy) 
    implementation of <tt>delete(key)</tt>.
    When we give an (eager) implementation of <tt>delete()</tt>, 
    it is intended to replace this default.
    
    <p><li><em>Iterators.</em>
    The <tt>keys()</tt> method returns an <tt>Iterable&lt;Key&gt;</tt>
    object for clients to use to iterate through the keys.
    
    <p><li><em>Key equality.</em>
    Java requires that all objects implement an 
    <tt>equals()</tt> method and provides
    implementations both for standard types such as 
    <tt>Integer</tt>, <tt>Double</tt>, and <tt>String</tt>
    and for more complicated types such as <tt>Date</tt>, <tt>File</tt> and 
    <tt>URL</tt>.
    For applications involving these types of data, you can just use the built-in 
    implementation.
    For example, if <tt>x</tt> and <tt>y</tt> are <tt>String</tt> values,
    then <tt>x.equals(y)</tt> is true if and only if <tt>x</tt> and <tt>y</tt>
    have the same length and are identical in each character position.
    In practice, keys might be more complicated, as in
    <a href = "Person.java.html">Person.java</a>.
    For such client-defined keys, you need to override <tt>equals()</tt>.
    Java's convention is that <tt>equals()</tt> must implement
    an <em>equivalence relation</em>:
    <ul>
    <li><em>Reflexive</em>: <tt>x.equals(x)</tt> is <tt>true</tt>.
    <li><em>Symmetric</em>: <tt>x.equals(y)</tt> is <tt>true</tt> if and only
    if <tt>y.equals(x)</tt> is <tt>true</tt>.
    <li><em>Transitive</em>: if <tt>x.equals(y)</tt> and <tt>y.equals(z)</tt>
    are <tt>true</tt>, then so is <tt>x.equals(z)</tt>.
    </ul>
    
    <p>In addition, <tt>equals()</tt> must take an
    <tt>Object</tt> as argument and satisfy the following 
    properties:
    
    <ul>
    <li><em>Consistency</em>: multiple invocations of <tt>x.equals(y)</tt>
    consistently return the same value, provided neither object
    is modified
    <li><em>Not null</em>: <tt>x.equals(null)</tt> returns <tt>false</tt>.
    </ul>
    
    <p>
    A best practice is to make <tt>Key</tt>
    types immutable, because consistency cannot otherwise be guaranteed.
    
    </ul>
    
    <p><h2>Ordered symbol tables.</h2>
    In typical applications, keys are <tt>Comparable</tt> objects, so 
    the option exists of using the code <tt>a.compareTo(b)</tt>
    to compare two keys <tt>a</tt> and <tt>b</tt>. 
    Several 
    symbol-table implementations take advantage of order among the keys that
    is implied by <tt>Comparable</tt> to provide efficient implementations of 
    the <tt>put()</tt> and <tt>get()</tt> operations. 
    More important, in such implementations, we can think of the symbol table as 
    keeping the keys in order and consider a significantly expanded API that defines 
    numerous natural and useful operations involving relative key order.
    For applications where keys are <tt>Comparable</tt>, we implement
    the following API:
    
    <p>
    <center>
    <IMG SRC="images/ordered-symbol-table-api.png" alt = "Ordered Symbol-table API">
    </center>
    
    
    <IMG SRC="images/ordered-symbol-table-ops.png"  align=right hspace=25 alt = "Examples of ordered symbol table operations">
    <ul>
    
    <p><li><em>Minimum and maximum.</em>
    Perhaps the most natural queries for a set of ordered keys are to ask for the 
    smallest and largest keys. We have already encountered the need for these 
    operations (in our discussion of priority queues in Section 3.4).
    
    <p><li><em>Floor and ceiling.</em>
    Given a key, it is often useful to be able to perform the
    <em>floor</em> operation
    (find the largest key that is less than or equal to the given key)
    and the <em>ceiling</em>
    operation (find the smallest key that is greater than or equal to the given key). 
    The nomenclature comes from functions defined on real numbers (the floor of a real 
    number x is the largest integer that is smaller than or equal to x and the ceiling 
    of a real number x is the smallest integer that is greater than or equal to x). 
    
    <p><li><em>Rank and selection.</em>
    The basic operations for determining 
    where a new key fits in the order are the <em>rank</em>
    operation (find the number of keys 
    less than a given key) and the <em>select</em>
    operation (find the key with a given rank). 
    We also have already encountered the need for these 
    operations, in our discussion of sort applications in Section 2.5.
    
    <p><li><em>Range queries.</em>
    How many keys fall within 
    a given range? Which keys fall in a given range?
    The two-argument <tt>size()</tt> and <tt>keys()</tt> 
    methods that answer these questions are useful in many applications, particularly 
    in large databases.
    
    <p><li><em>Delete minimum and delete maximum.</em>
    Our ordered symbol table API adds to the basic API methods
    to delete the maximum and minimum keys (and their associated values).
    
    <p><li><em>Exceptional cases.</em>
    When a method is to return a key and there is no key fitting the description 
    in the table, our convention is to throw an exception.
    
    <p><li><em>Key equality (revisited).</em>
    The best practice in Java is to make <tt>compareTo()</tt>
    consistent with <tt>equals()</tt> in all 
    <tt>Comparable</tt> types. That is,
    for every pair of objects <tt>a</tt> and <tt>b</tt>
    in any give <tt>Comparable</tt>
    type, it should be the case that <tt>(a.compareTo(b) == 0)</tt> and
    <tt>a.equals(b)</tt> have the same value.
    
    </ul>
    
    <p><h2>Sample clients.</h2>
    We consider two clients: a test client that we use to trace algorithm
    behavior on small inputs and a performance client.
    
    <ul>
    <p><li><em>Test client.</em>
    The <tt>main()</tt> client in each of our symbol table implementations
    reads in a sequence of strings from standard input, builds a
    symbol table by associating the value i with the ith key in
    the input, and then prints the table.
    
    <p><li><em>Frequency counter.</em>
    Program <a href = "FrequencyCounter.java.html">FrequencyCounter.java</a>
    is a symbol-table client that finds the number 
    of occurrences of each string (having at least as many characters as a given 
    threshold length) in a sequence of strings from standard input,
    then iterates through the keys to find the one that occurs the most
    frequently.
    </ul>
    
    
    <p><h2>Sequential search in an unordered linked list.</h2>
    Program <a href = "SequentialSearchST.java.html">SequentialSearchST.java</a>
    implements a symbol table with a linked list of nodes that contain keys and values.
    To implement <tt>get()</tt>, we scan through the list,
    using <tt>equals()</tt> to compare the search key 
    with the key in each node in the list. If we find the match, we return the 
    associated value; if not, we return <tt>null</tt>.
    To implement <tt>put()</tt>, we also scan through 
    the list, using <tt>equals()</tt>
    to compare the client key with the key in each node in the 
    list. If we find the match, we update the value associated with that key to be the 
    value given in the second argument; if not, we create a new node with the given key 
    and value and insert it at the beginning of the list.
    This method is known as <em>sequential search</em>.
    
    <p>
    <center>
    <IMG SRC="images/sequential-search.png" alt = "Sequential search">
    </center>
    
    <p><h3>Proposition A.</h3>
    Unsuccessful search and insert in an (unordered) linked-list
    symbol table both use N compares, and successful search uses N compares
    in the worst case.
    In particular, inserting N keys into an initially empty linked-list
    symbol table uses ~N^2/2 compares.
    
    
    <p><h2>Binary search in an ordered array</h2>.
    Program <a href = "BinarySearchST.java.html">BinarySearchST.java</a>
    implements the ordered symbol table API.
    The underlying data structure is two parallel array, with the keys kept in order.
    The heart of the implementation is the <tt>rank()</tt> method,
    which returns the number of keys smaller than a given key.
    For <tt>get()</tt>, the rank tells us precisely where the key is
    to be found if it is in the table (and, if it is not there,
    that it is not in the table). For <tt>put()</tt>, the 
    rank tells us precisely where to update the value when the key
    is in the table, and precisely where to put the key when the key
    is not in the table. We move all larger 
    keys over one position to make room (working from back to front) and insert the 
    given key and value into the proper positions in their respective arrays.
    
    <p>
    <center>
    <IMG SRC="images/binary-search.png" alt = "Binary search symbol table">
    </center>
    
    <ul>
    <p><li><em>Binary search.</em>
    The reason that we keep keys in an ordered array is so that we can 
    use array indexing to dramatically reduce the number of compares required for each 
    search, using a venerable classic algorithm known as <em>binary search</em>.
    The basic idea is simple: we maintain indices into the sorted key array 
    that delimit the subarray that might contain the search key.
    To search, we compare the search key against the key in the middle of the 
    subarray. If the search key is less than the key in the middle, we search in the 
    left half of the subarray; if the search key is greater than the key in the middle 
    we search in the right half of the subarray; otherwise the key in the middle is 
    equal to the search key.
    
    <p>
    <center>
    <IMG SRC="images/rank.png" alt = "Rank">
    </center>
    
    <p><li><em>Other operations.</em>
    Since the keys are kept in an ordered array,
    most of the order-based operations are compact and straightforward.
    
    </ul>
    
    <p><h3>Proposition B.</h3>
    Binary search in an ordered array with N keys uses no more
    than lg N + 1 compares for a search (successful or unsuccessful)
    in the worst case.
    
    
    <p><h3>Proposition C.</h3>
    Inserting a new key into an ordered array uses ~ 2N array accesses
    in the worst case, so inserting N keys into an initially empty table
    uses ~ N^2 array accesses in the worst case.
    
    <p><br>